\section{O Programa}

O corpo do programa foi desenvolvido em Python 3.6+, utilizando a biblioteca padrão em conjunto com as bibliotecas OpenCV, para leitura e escrita das imagens, NumPy e SciPy, para as técnicas de limiarização local.

Em especial, a limiarização local foi implementada com a função \mintinline{python3}{generic_filter} \autocite{ref:genericfilter} do SciPy. Para acelerar um pouco o processamento, as funções de cálculo do limiar que são passadas como argumento da \mintinline{python3}{generic_filter} foram implementadas em C (padrão GNU11) e requerem o compilador GCC 4.7+ na primeira execução do programa.

\subsection{Código Fonte}

    O código fonte foi separado nos seguintes arquivos, dentro da pasta \texttt{limiarizacao}:

    \begin{description}
        \item[\_\_main\_\_.py] Processamento os comandos e as opções da linha de comando.

        \item[metodos] Pacote interno com as operações de limiarização.

        \begin{description}
            \item[metodos/\_\_init\_\_.py] Classes e objetos para as técnicas de limiarização e tratamento dos parâmetros de cada técnica, pelos argumentos da linha de comando.

            \item[metodos/locais.py] Wrapper para a chamada das funções em C.

            \item[metodos/locais.c] Funções de cálculo do limiar da vizinhança do pixel.

            \item[metodos/ops.c] Operações de mínimo, máximo, média, desvio padrão e mediana.
        \end{description}

        \item[inout.py] Tratamento de entrada e saída do programa.

        \item[tipos.py] Tipos para checagem estática com \texttt{mypy} \autocite{ref:mypy}.
    \end{description}

    Todas as figuras base utilizadas neste relatório podem ser encontradas na pasta \texttt{imagens} do código fonte, como descrito \red{SECIMG}. Além disso, \red{FOI ??} disponibilizado também um \textit{script} em \texttt{bash}, \texttt{run.sh}, que realiza todos os processamentos apresentados no relatório.

\subsection{Execução} \label{sec:execucao}

    A execução deve ser feita através do interpretador de Python 3.7+. A única entrada obrigatória é o caminho para a imagem PNG que será processada. Ao final da execução, a imagem resultante será exibida na tela.

    % \begin{figure}[H]
    %     \centering
    %     \includegraphics[width=6cm]{resultados/execucao.png}

    %     \caption{Aplicação de pontilhado com a \texttt{baboon.png}.}
    %     \label{fig:execucao}
    % \end{figure}

    Os argumentos opicionais podem ser vistos com \mintinline{bash}{$ python3 main.py --help}. A mais importante das opções é \mintinline{text}{--output}, ou \mintinline{text}{-o}, que salva o resultado em um arquivo PNG em vez de exibir na tela. Se é desejável tanto a exibição da imagem quanto o salvamento no arquivo, o argumento \mintinline{text}{--force-show} ou \mintinline{text}{-f} pode ser usado. Também existe a opção \mintinline{bash}{--grayscale} ou \mintinline{bash}{-g} que faz o processamento em escala de cinza.

    As outras opções são referentes à técnica de pontilhado. A flag \mintinline{bash}{--varredura} ou \mintinline{bash}{-v} controla a forma de varrredura na imagem, como descrito na \cref{sec:varredura}. A distribuição de erros aplicada pode ser modificada com \mintinline{bash}{--destribuicao} ou \mintinline{bash}{-d} e aceita o nome de qualquer um dos idealizadores da distribuição.

    Por exemplo, o comando abaixo apresenta a \cref{fig:execucao} em uma nova janela gráfica.

    \begin{minted}{bash}
        $ python3 main.py imagens/baboon.png -g -d ninke
    \end{minted}

\subsection{A biblioteca Numba}

    A ferramenta foi desenvolvida com requerimento mínimo sendo apenas o NumPy. No entanto, se presente, a biblioteca Numba causa um grande diferencial no tempo de execução das técnicas de pontilhado (cerca de trinta vezes mais rápido na máquina de desenvolvimento). Por isso, a biblioteca é fortemente recomendada na execução do código.
